Câu 1. Ví dụ nào dưới đây là không phải là 1 dịch vụ web phức tạp
A. Xem thông tin thời tiết
B. Đặt phòng khách sạn
==C. Lấy thông tin báo giá
D. Đặt vé máy bay

Câu 2. Đặc điểm nào sau đây không phải là một lợi ích của loose coupling trong dịch vụ web?
A. Tăng tính mở rộng và tái sử dụng của dịch vụ web
B. Giảm độ phức tạp và ràng buộc giữa các thành phần
C. Dễ dàng thay đổi và cập nhật các thành phần mà không ảnh hưởng đến toàn bộ hệ thống
==D. Tăng hiệu suất và tốc độ truyền thông trong dịch vụ web

Câu 3. Một giao diện dịch vụ có thể có bao nhiêu thực thi dịch vụ
A. Mỗi giao diện dịch vụ chỉ được phép có duy nhất 1 thực thi
B. Số lượng giao diện dịch vụ không vượt quá số lượng giao thức triển khai
C. Số lượng giao diện dịch vụ không vượt quá số lượng endpoint triển khai
==D. Mỗi giao diện có thể có nhiều thực thi

Câu 4. Dịch vụ loại nào được sử dụng để xử lý các thực thể kinh doanh liên quan, như hóa đơn, khách hàng hoặc yêu cầu?
A. Task service
B. Microservice
==C. Entity service
D. Utility service

Câu 5. Dịch vụ loại nào thường có phạm vi chức năng nhỏ và có yêu cầu xử lý và triển khai cụ thể?
A. Task service
B. Microservice
C. Entity service
==D. Utility service

Câu 6. Đặc điểm nào sau đây không nằm trong các đặc trưng của mô hình SOA?
==A. Phát triển mô hình riêng lẻ
B. Hướng mô hình kinh doanh
C. Lấy doanh nghiệp làm trung tâm
D. Nhà cung cấp trung lập

Câu 7. Task Service đóng vai trò gì trong các hệ thống hướng dịch vụ?
A. Quản lý các thực thể dữ liệu trong cơ sở dữ liệu
==B. Điều phối và quản lý các quy trình kinh doanh phức tạp
C. Cung cấp các chức năng tiện ích độc lập
D. Xác định các quan hệ giữa các dịch vụ thực thể

Câu 8. Trong quy trình mô hình hóa Web service, việc soát lại ứng viên tổ hợp dịch vụ có thể thêm những layer nào vào ứng viên tổ hợp dịch vụ?
A. Task service và microservice
B. Microservice và entity service
C. Microservice và utility service
==D. Entity service và utility service

Câu 9. Trong phân tích hướng dịch vụ, các agnostic logic trong quy trình kinh doanh là những logic như thế nào?
==A. Có khả năng tái sử dụng lại cao trong nhiều quy trình nghiệp vụ
B. Chỉ phục vụ một quy trình nghiệp vụ cụ thể và không thể tái sử dụng trong các quy trình khác
C. Liên quan đến việc xử lý dữ liệu của các hệ thống cụ thể mà không phụ thuộc vào ngữ cảnh nghiệp vụ
D. Yêu cầu sự tùy chỉnh đặc thù cho từng quy trình nghiệp vụ

Câu 10. Tại sao việc áp dụng nguyên tắc Lược đồ chuẩn là quan trọng trong thiết kế dịch vụ thực thể?
==A. Để đảm bảo tính nhất quán và tính tái sử dụng của lược đồ XML
B. Để giảm thiểu việc lặp lại lược đồ
C. Để tăng cường tính bảo mật của dịch vụ
D. Để tối ưu hóa hiệu suất dịch vụ

Câu 11. Thuộc tính style với giá trị "document" hỗ trợ việc gì?
==A. Nhúng toàn bộ tài liệu XML trong phần thân SOAP
B. Biểu diễn dữ liệu loại tham số
C. Hỗ trợ việc giao tiếp RPC truyền thống
D. Áp dụng các kiểu dữ liệu XML Schema

Câu 12. Điều gì cần được đảm bảo trước khi thực hiện mở rộng một hợp đồng dịch vụ?
A. Tính nhất quán và dự đoán của SOA
B. Tính mở rộng của các khả năng dịch vụ
==C. Các tiêu chuẩn quản lý phiên bản đã được thiết lập
D. Tính mở rộng của phạm vi chức năng dịch vụ

Câu 13. What is the main characteristic of synchronous communication between microservices?
A. Messages are queued before delivery
B. Requests are fire-and-forget
==C. Client waits for immediate response
D. Data is transferred in batch

Câu 14. Which pattern coordinates transactions that span across multiple services?
A. Service Mesh
B. Circuit Breaker
==C. Saga
D. Webhooks

Câu 15. Which event pattern supports eventual consistency in microservices?
A. Observer
B. Saga
==C. Domain Event
D. Chain of Responsibility

Câu 16. What principle helps isolate changes in business logic?
A. Modularization
==B. Domain-driven design
C. Encapsulation
D. Continuous deployment

Câu 17. Which DevOps practice is critical to microservices success?
A. Manual testing
B. Manual deployment
==C. Continuous Integration/Continuous Delivery
D. Monthly backups

Câu 18. What is a benefit of decentralized governance in microservices?
A. Uniform technology stack
==B. Freedom to choose suitable tools per service
C. No need for service boundaries
D. Eliminating testing requirements

Câu 19. What is the primary purpose of a deployment pipeline in microservices architecture?
A. To manage version control
==B. To automate service deployment
C. To store container images
D. To build frontend interfaces

Câu 20. In Kubernetes, what mechanism can automatically roll back a failed deployment?
A. Pod eviction
B. Horizontal scaling
C. Liveness probe
==D. Deployment controller

Câu 21. What does CQRS stand for in the context of event sourcing?
A. Command Query Remote Server
B. Centralized Query Result Store
==C. Command Query Responsibility Segregation
D. Continuous Queue Record Synchronization

Câu 22. What role do projections play in an event-sourced system?
A. They serve as backups of event logs
B. They enforce access control policies
==C. They transform events into queryable views
D. They update the command model

Câu 23. What is one of the main reasons for using an API gateway in a microservices architecture?
A. To increase database performance
B. To expose internal service APIs directly
==C. To act as a single entry point for clients
D. To remove the need for load balancing

Câu 24. Which pattern is best suited for tailoring APIs to different client needs like mobile vs desktop?
==A. Backend for frontends
B. Service discovery
C. Single page apps
D. Event sourcing

Câu 25. Which protocol is commonly used for synchronous HTTP communication between services?
==A. gRPC
B. WebSockets
C. SMTP
D. Kafka

Câu 26. What technique helps handle messages that cannot be processed immediately?
A. Web scraping
==B. Dead letter queue
C. Session caching
D. Rate limiting

Câu 27. Which database type is often used for read models in microservices?
A. Graph databases for all use cases
B. Write-optimized SQL only
==C. Read-optimized NoSQL or denormalized SQL
D. Blockchain ledgers

Câu 28. Why might a system prefer using separate read databases in microservices?
A. To ensure all services can write simultaneously
==B. To reduce latency and optimize for read performance
C. To reduce the number of microservices
D. To enforce tighter consistency

Câu 29. How should services communicate to ensure eventual consistency in transactions?
A. Using a shared memory
B. Using REST with immediate consistency
==C. Using asynchronous messaging
D. Using database locks

Câu 30. When using the saga pattern, what is a downside of the choreography-based coordination?
A. Too much centralized control
==B. Reduced observability and debugging difficulty
C. High cost
D. Poor security

Câu 31. Nhược điểm chính của việc sử dụng REST là gì?
A. Không dễ phát triển như SOAP
B. Không an toàn như SOAP
==C. Không phải là một giao thức tiêu chuẩn
D. Không hiệu quả như SOAP

Câu 32. Lợi ích chính của việc sử dụng dịch vụ web dựa trên REST là gì?
A. Dễ phát triển hơn SOAP
B. Hiệu quả hơn SOAP
C. An toàn hơn SOAP
==D. Đơn giản hơn SOAP

Câu 33. Cho đoạn mã nguồn:
@Path("/orders")
public class OrderResource {
    @GET
    @Produces(MediaType.APPLICATION_JSON)
    public Response getOrders() {
        // Get all orders from the database.
        return Response.ok(orders).build();
    }
    @POST
    @Consumes(MediaType.APPLICATION_JSON)
    public Response createOrder(Order order) {
        // Create a new order in the database.
        return Response.ok().build();
    }
    @PUT
    @Path("{id}")
    @Consumes(MediaType.APPLICATION_JSON)
    public Response updateOrder(@PathParam("id") long id, Order order) {
        // Update the order with the given ID in the database.
        return Response.ok().build();
    }
    @DELETE
    @Path("{id}")
    public Response deleteOrder(@PathParam("id") long id) {
        // Delete the order with the given ID from the database.
        return Response.ok().build();
    }
}
HTTP Request nào sẽ được chuyển cho getOrders () ?
A. Phương thức POST, đường dẫn /orders
B. Phương thức PUT, đường dẫn /orders
C. Phương thức GET, đường dẫn /orders/15
==D. Phương thức GET, đường dẫn /orders

Câu 34. Cho đoạn mã nguồn:
@Path("/products")
public class ProductResource {
    @GET
    @Produces(MediaType.APPLICATION_JSON)
    public Response getProducts() {
        // Get all products from the database.
        return Response.ok(products).build();
    }
    @POST
    @Consumes(MediaType.APPLICATION_XML)
    public Response createProduct(Product product) {
        // Create a new product in the database.
        return Response.ok().build();
    }
    @PUT
    @Path("{id}")
    @Consumes(MediaType.MULTIPART_FORM_DATA)
    public Response updateProduct(@PathParam("id") long id, Product product) {
        // Update the product with the given ID in the database.
        return Response.ok().build();
    }
    @DELETE
    @Path("{id}")
    public Response deleteProduct(@PathParam("id") long id) {
        // Delete the product with the given ID from the database.
        return Response.ok().build();
    }
}
Phương thức HTTP cho phương thức createProduct() là gì?
A. GET
==B. POST
C. PUT
D. DELETE

Câu 35. Cho đoạn mã nguồn:
@Path("/products")
public class ProductResource {
    @GET
    @Produces(MediaType.APPLICATION_JSON)
    public Response getProducts() {
        // Get all products from the database.
        return Response.ok(products).build();
    }
    @POST
    @Consumes(MediaType.APPLICATION_XML)
    public Response createProduct(Product product) {
        // Create a new product in the database.
        return Response.ok().build();
    }
    @PUT
    @Path("{id}")
    @Consumes(MediaType.MULTIPART_FORM_DATA)
    public Response updateProduct(@PathParam("id") long id, Product product) {
        // Update the product with the given ID in the database.
        return Response.ok().build();
    }
    @DELETE
    @Path("{id}")
    public Response deleteProduct(@PathParam("id") long id) {
        // Delete the product with the given ID from the database.
        return Response.ok().build();
    }
}
HTTP Request nào sẽ không được chuyển cho updateProduct () ?
A. Phương thức PUT, đường dẫn /products/15
==B. Phương thức PUT, đường dẫn /products
C. Phương thức PUT, đường dẫn /products/16
D. Phương thức PUT, đường dẫn /products/17

Câu 36. Trong WSDL, phần message dùng để làm gì?
==A. Mô tả kiểu dữ liệu và nội dung của một message được gửi hoặc nhận
B. Chứa các tài nguyên của web service
C. Chứa các thư viện lập trình
D. Chứa các tài liệu hướng dẫn

Câu 37. Phương thức HTTP nào được sử dụng để lấy thông tin resource trong Restful web service?
A. DELETE
B. POST
C. PUT
==D. GET

Câu 38. Cho định nghĩa WSDL:
<wsdl:definitions xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" ...>
    ...
    <wsdl:message name="ChargeRequest">
        <wsdl:part name="customer" element="tns:Customer" />
        <wsdl:part name="charge" element="tns:Charge" />
    </wsdl:message>
    <wsdl:message name="ChargeResponse">
        <wsdl:part name="result" element="tns:ChargeResult" />
    </wsdl:message>
    <wsdl:portType name="OnlineChargingPortType">
        <wsdl:operation name="Charge">
            <wsdl:input message="tns:ChargeRequest" />
            <wsdl:output message="tns:ChargeResponse" />
        </wsdl:operation>
    </wsdl:portType>
    ...
</wsdl:definitions>
Thông điệp nào có thể được gửi đến dịch vụ web OnlineCharging?
==A. ChargeRequest
B. ChargeResponse
C. Charge
D. ChargeResult

Câu 39. Cho định nghĩa WSDL:
<wsdl:definitions ...>
    <wsdl:types>
        <xsd:schema ...>
            <xsd:element name="Customer">
                <xsd:complexType>
                    <xsd:sequence>
                        <xsd:element name="CustomerId" type="xsd:string" minOccurs="1" />
                        <xsd:element name="CustomerName" type="xsd:string" minOccurs="1" />
                    </xsd:sequence>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="Charge">
                <xsd:complexType>
                    <xsd:sequence>
                        <xsd:element name="CustomerId" type="xsd:string" minOccurs="1" />
                        <xsd:element name="Amount" type="xsd:double" minOccurs="1" />
                    </xsd:sequence>
                </xsd:complexType>
            </xsd:element>
            ...
        </xsd:schema>
    </wsdl:types>
    ...
</wsdl:definitions>
Đâu không phải là một phần tử đơn ?
A. CustomerName
B. CustomerId
C. Amount
==D. Customer

Câu 40. Cho định nghĩa WSDL:
<?xml version="1.0" encoding="UTF-8"?>
<definitions ...>
    <types>
        <xsd:schema ...>
            <xsd:element name="Account">
                ...
            </xsd:element>
            <xsd:element name="AccountResponse">
                <xsd:complexType>
                    <xsd:sequence>
                        <xsd:element name="success" type="xsd:boolean"/>
                    </xsd:sequence>
                </xsd:complexType>
            </xsd:element>
        </xsd:schema>
    </types>
    <message name="RegisterAccount">
        <part name="parameters" element="tns:Account"/>
    </message>
    <message name="RegisterAccountResponse">
        <part name="parameters" element="tns:AccountResponse"/>
    </message>
    <portType name="AccountRegistrationPortType">
        <operation name="RegisterAccount">
            <input message="tns:RegisterAccount"/>
            <output message="tns:RegisterAccountResponse"/>
        </operation>
    </portType>
    ...
</definitions>
Thông tin nào được dịch vụ web trả về?
A. Tên người dùng
B. Mật khẩu
==C. Thành công hay không
D. Tên người dùng và mật khẩu