Câu 1: SOA tập trung vào việc gì?
A. Xây dựng ứng dụng di động
B. Phân tích dữ liệu
==C. Tích hợp các hệ thống khác nhau
D. Phân loại dữ liệu

Câu 2: Khi xây dựng một dịch vụ web đặt vé xem phim, việc áp dụng độ mịn như thế nào có thể giúp tăng khả năng mở rộng của hệ thống?
==A. Áp dụng độ mịn để chia nhỏ các chức năng như quản lý phim, quản lý rạp chiếu, quản lý đặt vé
B. Áp dụng độ mịn để gộp các chức năng đặt vé thành một dịch vụ duy nhất
C. Áp dụng độ mịn không ảnh hưởng đến khả năng mở rộng của hệ thống
D. Áp dụng độ mịn chỉ cần xác định các API cho việc đặt vé

Câu 3: Ví dụ nào dưới đây là 1 thuộc tính phi chức năng của dịch vụ web là gì?
A. Quản lý dữ liệu hiệu quả
B. Giao diện người dùng dễ sử dụng
==C. Thời gian đáp ứng yêu cầu
D. Tích hợp với các hệ thống khác

Câu 4: Vì sao khi thiết kế kiến trúc dịch vụ cần lấy doanh nghiệp làm trung tâm?
A. Để dùng chung các service
B. Tránh nguy cơ tạo ra các silo mới trong doanh nghiệp
==C. Tránh các dịch vụ xa rời mục đích kinh doanh
D. Tuổi thọ kiến trúc thấp

Câu 5: Điều kiện để một dịch vụ được coi là bất khả tri?
==A. Chứa logic có khả năng tái sử dụng bởi nhiều quy trình kinh doanh
B. Chứa logic được sử dụng trong một quy trình kinh doanh duy nhất
C. Các chức năng được phát triển từ các thực thể
D. Các chức năng chỉ gồm logic không liên quan đến thực thể

Câu 6: Mục đích của quá trình mô hình hóa dịch vụ là gì?
A. Tổ chức các đơn vị logic thành các giải pháp hướng dịch vụ
B. Phân loại các đơn vị logic dựa trên kích thước của chúng
C. Tạo nhãn cho các lớp hướng dịch vụ
==D. Xác định bản chất của các đơn vị logic

Câu 7: Sự khác biệt chính giữa RESTful services và SOAP-based web services trong phân tích hướng dịch vụ là gì?
A. Tối ưu hóa hiệu suất của các dịch vụ
==B. Xác định ranh giới chính xác cho các dịch vụ
C. Xác định giao diện của các dịch vụ
D. Xác định các thực thể kinh doanh cần dịch vụ hỗ trợ

Câu 8: Quá trình mô hình hóa dịch vụ có cần phải đảm bảo tính linh hoạt của hợp đồng dịch vụ?
==A. Có, để dễ dàng cập nhật và thay đổi trong quá trình phát triển
B. Không, để đảm bảo tính nhất quán và ổn định của dịch vụ
C. Có, để giảm thiểu sự phức tạp của dịch vụ
D. Không, để giảm thiểu rủi ro và lỗi trong quá trình triển khai

Câu 9: Trong quy trình mô hình hóa web service, ứng viên dịch vụ nào được xác định đầu tiên?
==A. Entity service
B. Task service
C. Microservice
D. Utility Service

Câu 10: Thuộc tính style với giá trị "document" hỗ trợ việc gì?
==A. Nhúng toàn bộ tài liệu XML trong phần thân SOAP
B. Biểu diễn dữ liệu loại tham số
C. Hỗ trợ việc giao tiếp RPC truyền thống
D. Áp dụng các kiểu dữ liệu XML Schema

Câu 11: Thuộc tính use với giá trị "literal" đại diện cho việc sử dụng hệ thống kiểu dữ liệu nào?
A. Hệ thống kiểu dữ liệu riêng của SOAP
==B. Hệ thống kiểu dữ liệu XML Schema
C. Hệ thống kiểu dữ liệu WSDL
D. Hệ thống kiểu dữ liệu RPC

Câu 12: (Nội dung câu hỏi bị thiếu, các lựa chọn bên dưới có thể liên quan đến mục đích của kiểu document/literal)
==A. Trao đổi tài liệu XML hoàn chỉnh
B. Gọi các hàm từ xa với các tham số
C. Gửi và nhận email
D. Quản lý file hệ thống

Câu 13: Which of the following is a primary reason for using asynchronous communication in microservices?
A. To reduce latency in request handling
B. To simplify service discovery
==C. To decouple services for better scalability
D. To enforce strict request-response patterns

Câu 14: Which service pattern supports observability in distributed systems?
A. Orchestration
==B. Tracing
C. Logging only
D. Database sharding

Câu 15: Which object-oriented design principle is encouraged for complex business logic?
==A. Encapsulation
B. Inheritance
C. Applying object-oriented design principles
D. Polymorphism

Câu 16: What does the Domain Event pattern facilitate?
A. Immediate data consistency
B. Long-running transactions
==C. Loose coupling between services
D. UI responsiveness

Câu 17: How can a service publish domain events to other services?
A. By using a shared memory object
B. Through REST polling
==C. Via event-driven messaging
D. Through FTP updates

Câu 18: When should a team split a monolith into microservices?
A. When the monolith is fast
==B. When modular boundaries are clear and aligned to business domains
C. When using a single tech stack
D. At the start of a project

Câu 19: To avoid configuration drift, what strategy is recommended?
A. Manual editing of each instance
B. Centralized logging
==C. Infrastructure as Code
D. Increasing replicas

Câu 20: What is a typical component of a CI/CD toolchain?
A. Load balancer
==B. Version control system
C. Firewall
D. Database driver

Câu 21: Which statement is true about deleting events in event sourcing?
A. Events can be deleted after being processed
==B. Events are immutable and typically not deleted
C. Events are deleted after each projection update
D. Events must be encrypted then deleted

Câu 22: Why is immutability important in event sourcing?
A. It reduces memory consumption
==B. It avoids concurrency issues and ensures auditability
C. It allows event deletion when necessary
D. It simplifies UI rendering

Câu 23: What is one of the main reasons for using an API gateway in a microservices architecture?
A. To increase database performance
B. To expose internal service APIs directly
==C. To act as a single entry point for clients
D. To remove the need for load balancing

Câu 24: What is the challenge with having a one-size-fits-all API in microservices?
A. It is always slower than direct DB queries
B. It requires GraphQL
==C. Different clients have different data needs and network constraints
D. It reduces reusability of services

Câu 25: Which protocol is commonly used for synchronous communication between services?
==A. gRPC
B. WebSockets
C. SMTP
D. Kafka

Câu 26: Which HTTP status code often indicates a downstream service is unavailable?
A. 200
B. 404
==C. 503
D. 301

Câu 27: How does the query side handle updates when using Event Sourcing?
A. By updating the database directly
==B. By consuming events and updating read models accordingly
C. By translating commands into updates
D. By replacing the entire dataset

Câu 28: Which mechanism is commonly used to propagate domain changes to query models?
A. HTTP polling
B. Direct database replication
==C. Domain events and messaging
D. API Gateway transforms

Câu 29: What is the key difference between monolithic and microservices-based transaction handling?
A. Monoliths handle distributed state
B. Microservices use centralized databases
==C. Microservices involve distributed transaction context
D. Monoliths cannot handle ACID properties

Câu 30: In an e-commerce checkout using saga, if the payment step fails, what should happen?
A. Notify admin only
==B. Compensate previous steps like canceling order and restocking
C. Retry indefinitely
D. Send error log

Câu 31: Dịch vụ web SOAP có hợp đồng không?
==A. Có
B. Không
C. Đôi khi
D. Tùy thuộc

Câu 32: Chú thích nào thường được sử dụng để chỉ định đường dẫn cho dịch vụ web?
==A. Chú thích @Path
B. Chú thích @RestController
C. Chú thích @RequestMapping
D. Chú thích @Service

Câu 33: Cho đoạn mã nguồn:
@Path("/products")
public class ProductResource {
    @GET
    @Produces(MediaType.APPLICATION_JSON)
    public Response getProducts() {
        // Get all products from the database.
        return Response.ok(products).build();
    }
    @POST
    @Consumes(MediaType.APPLICATION_XML)
    public Response createProduct(Product product) {
        // Create a new product in the database.
        return Response.ok().build();
    }
    @PUT
    @Path("{id}")
    @Consumes(MediaType.MULTIPART_FORM_DATA)
    public Response updateProduct(@PathParam("id") long id, Product product) {
        // Update the product with the given ID in the database.
        return Response.ok().build();
    }
    @DELETE
    @Path("{id}")
    public Response deleteProduct(@PathParam("id") long id) {
        // Delete the product with the given ID from the database.
        return Response.ok().build();
    }
}
Kiểu dữ liệu cho yêu cầu của phương thức createProduct() là gì?
A. text/plain
B. application/json
==C. application/xml
D. image/jpeg

Câu 34: Cho đoạn mã nguồn:
@Path("/products")
public class ProductResource {
    @GET
    @Produces(MediaType.APPLICATION_JSON)
    public Response getProducts() {
        // Get all products from the database.
        return Response.ok(products).build();
    }
    @POST
    @Consumes(MediaType.APPLICATION_XML)
    public Response createProduct(Product product) {
        // Create a new product in the database.
        return Response.ok().build();
    }
    @PUT
    @Path("{id}")
    @Consumes(MediaType.MULTIPART_FORM_DATA)
    public Response updateProduct(@PathParam("id") long id, Product product) {
        // Update the product with the given ID in the database.
        return Response.ok().build();
    }
    @DELETE
    @Path("{id}")
    public Response deleteProduct(@PathParam("id") long id) {
        // Delete the product with the given ID from the database.
        return Response.ok().build();
    }
}
HTTP Request nào sẽ được chuyển cho updateProduct () ?
A. Phương thức PUT, đường dẫn /products
==B. Phương thức PUT, đường dẫn /products/15
C. Phương thức GET, đường dẫn /products/15
D. Phương thức GET, đường dẫn /products

Câu 35: Cho đoạn mã nguồn:
@Path("/products")
public class ProductResource {
    @GET
    @Produces(MediaType.APPLICATION_JSON)
    public Response getProducts() {
        // Get all products from the database.
        return Response.ok(products).build();
    }
    @POST
    @Consumes(MediaType.APPLICATION_XML)
    public Response createProduct(Product product) {
        // Create a new product in the database.
        return Response.ok().build();
    }
    @PUT
    @Path("{id}")
    @Consumes(MediaType.MULTIPART_FORM_DATA)
    public Response updateProduct(@PathParam("id") long id, Product product) {
        // Update the product with the given ID in the database.
        return Response.ok().build();
    }
    @DELETE
    @Path("{id}")
    public Response deleteProduct(@PathParam("id") long id) {
        // Delete the product with the given ID from the database.
        return Response.ok().build();
    }
}
Phương thức HTTP cho phương thức deleteProduct() là gì?
A. GET
B. POST
C. PUT
==D. DELETE

Câu 36: Trong WSDL, một message có thể chứa các kiểu dữ liệu nào?
A. Dữ liệu nguyên thủy
B. Complex Type
C. Array Type
==D. Cả A và B

Câu 37: Trong WSDL, phần PortType dùng để làm gì?
A. Chứa các thông tin bổ sung về message
B. Chứa thông tin về tài nguyên của web service
==C. Định nghĩa các phương thức và kiểu dữ liệu
D. Chứa các thư viện lập trình

Câu 38: Cho định nghĩa WSDL:
<wsdl:definitions ...>
    <wsdl:types>
        <xsd:schema ...>
            <xsd:element name="Customer">
                <xsd:complexType>
                    <xsd:sequence>
                        <xsd:element name="CustomerId" type="xsd:string" minOccurs="1" />
                        <xsd:element name="CustomerName" type="xsd:string" minOccurs="1" />
                    </xsd:sequence>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="Charge">...</xsd:element>
            <xsd:element name="ChargeResult">...</xsd:element>
        </xsd:schema>
    </wsdl:types>
    ...
</wsdl:definitions>
Đâu không phải là một phần tử phức ?
A. Customer
==B. CustomerId
C. Charge
D. ChargeResult

Câu 39: Cho định nghĩa WSDL:
<?xml version="1.0" encoding="UTF-8"?>
<definitions ...>
    <types>
        <xsd:schema ...>
            <xsd:element name="Account">...</xsd:element>
            <xsd:element name="AccountResponse">
                <xsd:complexType>
                    <xsd:sequence>
                        <xsd:element name="success" type="xsd:boolean"/>
                    </xsd:sequence>
                </xsd:complexType>
            </xsd:element>
        </xsd:schema>
    </types>
    <message name="RegisterAccountResponse">
        <part name="parameters" element="tns:AccountResponse"/>
    </message>
    ...
</definitions>
Thông tin nào được dịch vụ web trả về?
A. Tên người dùng
B. Mật khẩu
==C. Thành công hay không
D. Tên người dùng và mật khẩu

Câu 40: Cho định nghĩa WSDL:
<?xml version="1.0" encoding="UTF-8"?>
<definitions ...>
    <types>
        <xsd:schema ...>
            <xsd:element name="Account">
                <xsd:complexType>
                    <xsd:sequence>
                        <xsd:element name="username" type="xsd:string"/>
                        <xsd:element name="password" type="xsd:string"/>
                    </xsd:sequence>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="AccountResponse">
                <xsd:complexType>
                    <xsd:sequence>
                        <xsd:element name="success" type="xsd:boolean"/>
                    </xsd:sequence>
                </xsd:complexType>
            </xsd:element>
        </xsd:schema>
    </types>
    ...
</definitions>
Đâu không phải là một phần tử đơn ?
A. success
B. username
C. password
==D. Account