Câu 1. Độ mịn dịch vụ (Service granularity) là gì?
==A. Độ đa dạng của các hoạt động trong một dịch vụ web
B. Độ tương tác giữa các dịch vụ web
C. Khả năng mở rộng của dịch vụ web
D. Mức độ kết nối giữa các dịch vụ web

Câu 2. Trong việc xây dựng một dịch vụ web bán hàng, việc áp dụng độ mịn như thế nào có thể giúp tăng khả năng mở rộng của hệ thống?
==A. Áp dụng độ mịn để chia nhỏ các chức năng như quản lý sản phẩm, quản lý đơn hàng, thanh toán
B. Áp dụng độ mịn để gộp các chức năng bán hàng thành một dịch vụ duy nhất
C. Áp dụng độ mịn không ảnh hưởng đến khả năng mở rộng của hệ thống
D. Áp dụng độ mịn chỉ cần xác định các API cho việc bán hàng

Câu 3. Ví dụ về dịch vụ web là "Thanh toán trực tuyến", loại dịch vụ này thuộc mô hình liên lạc đồng bộ hay không đồng bộ?
A. Không đồng bộ
==B. Đồng bộ
C. Cả A, B đều đúng
D. Không cái nào đúng

Câu 4. Sắp xếp theo thứ tự quy mô lớn dần các loại SOA phổ biến?
==A. Kiến trúc dịch vụ, Kiến trúc thành phần dịch vụ, Kiến trúc kho dịch vụ, Kiến trúc doanh nghiệp hướng dịch vụ
B. Kiến trúc dịch vụ, Kiến trúc kho dịch vụ, Kiến trúc thành phần dịch vụ, Kiến trúc doanh nghiệp hướng dịch vụ
C. Kiến trúc kho dịch vụ, Kiến trúc dịch vụ, Kiến trúc thành phần dịch vụ, Kiến trúc doanh nghiệp hướng dịch vụ
D. Kiến trúc thành phần dịch vụ, Kiến trúc doanh nghiệp hướng dịch vụ, Kiến trúc kho dịch vụ, Kiến trúc dịch vụ

Câu 5. Định nghĩa microservice trong kiến trúc hướng dịch vụ (SOA)?
A. Một dịch vụ bất khả tri thường có phạm vi chức năng nhỏ bao gồm logic với các yêu cầu xử lý và triển khai cụ thể
==B. Một dịch vụ không bất khả tri thường có phạm vi chức năng nhỏ bao gồm logic với các yêu cầu xử lý và triển khai cụ thể
C. Một dịch vụ lớn được chia nhỏ thành các thành phần nhỏ hơn
D. Một dịch vụ được thiết kế để chạy trên nhiều máy chủ khác nhau

Câu 6. Mục đích chính của quá trình mô hình hóa dịch vụ trong kiến trúc dịch vụ (SOA) là gì?
A. Xác định quy trình kết hợp các dịch vụ thành một giải pháp hướng dịch vụ
B. Xác định các yêu cầu và chức năng của các dịch vụ trong hệ thống
==C. Tổ chức một lượng lớn các đơn vị logic để cuối cùng chúng có thể được tập hợp lại thành các giải pháp hướng dịch vụ
D. Xác định cấu trúc và quan hệ giữa các dịch vụ trong kiến trúc dịch vụ

Câu 7. Logic khả tri là gì?
A. Logic dành riêng cho một nhiệm vụ có mục đích duy nhất
B. Logic dành riêng cho một nhiệm vụ có đa mục đích
==C. Logic đủ chung chung, không cụ thể, không liên quan đến một nhiệm vụ gốc cụ thể
D. Logic đủ chung chung, không cụ thể, dành cho nhiệm vụ có mục đích duy nhất

Câu 8. Sự khác biệt chính giữa RESTful services và SOAP-based web services trong phân tích hướng dịch vụ là gì?
A. Tối ưu hóa hiệu suất của các dịch vụ
B. Xác định ranh giới chính xác cho các dịch vụ
==C. Xác định giao diện của các dịch vụ
D. Xác định các thực thể kinh doanh cần dịch vụ hỗ trợ

Câu 9. Vai trò của Entity Service trong kiến trúc dịch vụ là gì?
A. Điều phối và thực hiện các nhiệm vụ cụ thể trong quy trình kinh doanh
==B. Cung cấp các chức năng liên quan đến CRUD (Create, Read, Update, Delete) cho các thực thể
C. Cung cấp các dịch vụ tiện ích chung mà nhiều dịch vụ khác có thể cần
D. Đơn vị triển khai độc lập, thực hiện một chức năng duy nhất và cụ thể trong hệ thống

Câu 10. Hợp đồng dịch vụ Web cần phản ánh chính xác điều gì?
A. Tên thao tác
==B. Chức năng và ngữ cảnh của dịch vụ
C. Quy trình nghiệp vụ
D. Tên dịch vụ

Câu 11. Hợp đồng dịch vụ Web được thiết kế để phản ánh chính xác điều gì?
A. Cách triển khai dịch vụ
==B. Ngữ cảnh và chức năng của các ứng viên dịch vụ tương ứng của chúng
C. Phần mềm cơ sở hạ tầng
D. Phân tích và thiết kế hệ thống

Câu 12. Mức độ chi tiết năng lực dịch vụ (Capability Granularity) được đo bằng gì?
A. Mức độ chi tiết của logic xác thực
==B. Phạm vi chức năng của khả năng dịch vụ
C. Số lượng dữ liệu được xử lý
D. Tất cả đều đúng

Câu 13. Which pattern is useful when a client needs to contact multiple services in one logical operation?
A. Service Mesh
==B. API Gateway
C. Saga
D. Backend for Frontend

Câu 14. What technique helps handle messages that cannot be processed immediately?
A. Web scraping
==B. Dead letter queue
C. Session caching
D. Rate limiting

Câu 15. Which design pattern is commonly combined with aggregates?
==A. Saga pattern
B. Factory pattern
C. Builder pattern
D. Prototype pattern

Câu 16. Which pattern should be used when object references span multiple services?
A. Repository pattern
B. Decorator pattern
==C. Aggregate pattern
D. Strategy pattern

Câu 17. How can a service publish domain events to other services?
A. By using a shared memory object
B. Through REST polling
==C. Via event-driven messaging
D. Through FTP updates

Câu 18. What is a benefit of decentralized governance in microservices?
A. Uniform technology stack
==B. Freedom to choose suitable tools per service
C. No need for service boundaries
D. Eliminating testing requirements

Câu 19. What is a typical component of a CI/CD toolchain?
A. Load balancer
==B. Version control system
C. Firewall
D. Database driver

Câu 20. How might you ensure zero downtime during deployment?
A. Manual script execution
B. Scaling down before deployment
==C. Using load balancer to shift traffic
D. Stopping old version before new one starts

Câu 21. What is the purpose of CQRS when used with event sourcing?
A. To execute events faster
==B. To separate the command model from the read model
C. To replicate data to multiple nodes
D. To reduce storage cost

Câu 22. Why is immutability important in event sourcing?
A. It reduces memory consumption
==B. It avoids concurrency issues and ensures auditability
C. It allows event deletion when necessary
D. It simplifies UI rendering

Câu 23. Why is designing the external API more challenging in microservices than in monoliths?
A. Microservices do not allow REST
==B. Each service has its own interface and clients vary
C. Clients always prefer SOAP
D. Clients do not use APIs

Câu 24. Which of the following best describes GraphQL in the context of API gateways?
A. It only works for REST services
B. It is a messaging queue
==C. It simplifies API composition by allowing clients to specify data needs
D. It replaces microservices

Câu 25. What is the main characteristic of synchronous communication between microservices?
A. Messages are queued before delivery
B. Requests are fire-and-forget
==C. Client waits for immediate response
D. Data is transferred in batch

Câu 26. Which pattern coordinates transactions that span across multiple services?
A. Service Mesh
B. Circuit Breaker
==C. Saga
D. Webhooks

Câu 27. What is a key benefit of using materialized views in query processing?
A. They reduce write latency
B. They support asynchronous communication
==C. They improve performance by precomputing results
D. They manage user sessions

Câu 28. What is the primary responsibility of the Query side in a microservices architecture?
A. To handle incoming commands and update data
==B. To listen for domain events and update read models
C. To manage authentication and authorization
D. To generate API documentation

Câu 29. In an e-commerce checkout using saga, if the payment step fails, what should happen?
A. Notify admin only
==B. Compensate previous steps like canceling order and restocking
C. Retry indefinitely
D. Send error log

Câu 30. When using the saga pattern, what is a downside of the choreography-based coordination?
A. Too much centralized control
==B. Reduced observability and debugging difficulty
C. High cost
D. Poor security

Câu 31. Dịch vụ dựa trên SOAP hay REST an toàn hơn?
A. SOAP
B. REST
==C. Tùy thuộc vào cách triển khai cụ thể
D. SOAP và REST có cùng mức độ an toàn

Câu 32. Dịch vụ dựa trên SOAP hay REST tốt hơn cho ứng dụng di động?
A. SOAP
==B. REST
C. Tùy thuộc vào ứng dụng
D. SOAP và REST đều có thể được sử dụng cho ứng dụng di động

Câu 33. Cho đoạn mã nguồn:
@Path("/products")
public class ProductResource {
   @GET
   @Produces(MediaType.APPLICATION_JSON)
   public Response getProducts() {
       // Get all products from the database.
       return Response.ok(products).build();
   }
   @POST
   @Consumes(MediaType.APPLICATION_XML)
   public Response createProduct(Product product) {
       // Create a new product in the database.
       return Response.ok().build();
   }
   @PUT
   @Path("{id}")
   @Consumes(MediaType.MULTIPART_FORM_DATA)
   public Response updateProduct(@PathParam("id") long id, Product product) {
       // Update the product with the given ID in the database.
       return Response.ok().build();
   }
   @DELETE
   @Path("{id}")
   public Response deleteProduct(@PathParam("id") long id) {
       // Delete the product with the given ID from the database.
       return Response.ok().build();
   }
}
HTTP Request nào sẽ được chuyển cho updateProduct () ?
A. Phương thức PUT, đường dẫn /products
==B. Phương thức PUT, đường dẫn /products/15
C. Phương thức GET, đường dẫn /products/15
D. Phương thức GET, đường dẫn /products

Câu 34. Cho đoạn mã nguồn:
@Path("/orders")
public class OrderResource {
   @GET
   @Produces(MediaType.APPLICATION_JSON)
   public Response getOrders() {
       // Get all orders from the database.
       return Response.ok(orders).build();
   }
   @POST
   @Consumes(MediaType.APPLICATION_JSON)
   public Response createOrder(Order order) {
       // Create a new order in the database.
       return Response.ok().build();
   }
   @PUT
   @Path("{id}")
   @Consumes(MediaType.APPLICATION_JSON)
   public Response updateOrder(@PathParam("id") long id, Order order) {
       // Update the order with the given ID in the database.
       return Response.ok().build();
   }
   @DELETE
   @Path("{id}")
   public Response deleteOrder(@PathParam("id") long id) {
       // Delete the order with the given ID from the database.
       return Response.ok().build();
   }
}
HTTP Request nào sẽ không được chuyển cho updateOrder () ?
A. Phương thức PUT, đường dẫn /orders/15
==B. Phương thức PUT, đường dẫn /orders
C. Phương thức PUT, đường dẫn /orders/16
D. Phương thức PUT, đường dẫn /orders/17

Câu 35. Cho đoạn mã nguồn:
@Path("/products")
public class ProductResource {
   @GET
   @Produces(MediaType.APPLICATION_JSON)
   public Response getProducts() {
       // Get all products from the database.
       return Response.ok(products).build();
   }
   @POST
   @Consumes(MediaType.APPLICATION_XML)
   public Response createProduct(Product product) {
       // Create a new product in the database.
       return Response.ok().build();
   }
   @PUT
   @Path("{id}")
   @Consumes(MediaType.MULTIPART_FORM_DATA)
   public Response updateProduct(@PathParam("id") long id, Product product) {
       // Update the product with the given ID in the database.
       return Response.ok().build();
   }
   @DELETE
   @Path("{id}")
   public Response deleteProduct(@PathParam("id") long id) {
       // Delete the product with the given ID from the database.
       return Response.ok().build();
   }
}
HTTP Request nào sẽ không được chuyển cho updateProduct () ?
A. Phương thức PUT, đường dẫn /products/15
==B. Phương thức PUT, đường dẫn /products
C. Phương thức PUT, đường dẫn /products/16
D. Phương thức PUT, đường dẫn /products/17

Câu 36. WSDL có thể mô tả được các thông tin nào của một web service?
A. Thông tin định dạng dữ liệu
==B. Thông tin địa chỉ và giao thức truy cập
C. Thông tin mã nguồn và kiểu dữ liệu
D. Thông tin cấu trúc dữ liệu

Câu 37. Trong WSDL, phần Output của một phương thức được định nghĩa để làm gì?
A. Chứa các tài nguyên của web service
B. Chứa các tham số đầu vào của phương thức
==C. Chứa các tham số trả về của phương thức
D. Chứa các thông tin bổ sung về message

Câu 38. Cho định nghĩa WSDL:
<?xml version="1.0" encoding="UTF-8"?>
<definitions xmlns="http://schemas.xmlsoap.org/wsdl/" xmlns:tns="http://www.example.com/accountRegistration" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" name="AccountRegistration" targetNamespace="http://www.example.com/accountRegistration">
  <types>
    <xsd:schema elementFormDefault="qualified" targetNamespace="http://www.example.com/accountRegistration">
      <xsd:element name="Account">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="username" type="xsd:string"/>
            <xsd:element name="password" type="xsd:string"/>
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="AccountResponse">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="success" type="xsd:boolean"/>
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>
    </xsd:schema>
  </types>
  <message name="RegisterAccount">
    <part name="parameters" element="tns:Account"/>
  </message>
  <message name="RegisterAccountResponse">
    <part name="parameters" element="tns:AccountResponse"/>
  </message>
  <portType name="AccountRegistrationPortType">
    <operation name="RegisterAccount">
      <input message="tns:RegisterAccount"/>
      <output message="tns:RegisterAccountResponse"/>
    </operation>
  </portType>
  <binding name="AccountRegistrationBinding" type="tns:AccountRegistrationPortType">
    <soap:binding transport="http://schemas.xmlsoap.org/soap/http"/>
    <operation name="RegisterAccount">
      <soap:operation soapAction="http://www.example.com/accountRegistration/RegisterAccount"/>
      <input>
        <soap:body use="literal"/>
      </input>
      <output>
        <soap:body use="literal"/>
      </output>
    </operation>
  </binding>
  <service name="AccountRegistrationService">
    <port name="AccountRegistrationPort" binding="tns:AccountRegistrationBinding">
      <soap:address location="http://www.example.com/accountRegistration"/>
    </port>
  </service>
</definitions>
Đâu không phải là một phần tử đơn ?
A. success
B. username
C. password
==D. Account

Câu 39. Cho định nghĩa WSDL:
<wsdl:definitions xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" xmlns:tns="http://www.example.com/onlinecharging" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" name="OnlineCharging" targetNamespace="http://www.example.com/onlinecharging">
  <wsdl:types>
    <xsd:schema elementFormDefault="qualified" targetNamespace="http://www.example.com/onlinecharging">
      <xsd:element name="Customer">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="CustomerId" type="xsd:string" minOccurs="1"/>
            <xsd:element name="CustomerName" type="xsd:string" minOccurs="1"/>
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="Charge">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="CustomerId" type="xsd:string" minOccurs="1"/>
            <xsd:element name="Amount" type="xsd:double" minOccurs="1"/>
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="ChargeResult">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="Status" type="xsd:string" minOccurs="1"/>
            <xsd:element name="Message" type="xsd:string" minOccurs="1"/>
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>
    </xsd:schema>
  </wsdl:types>
  <wsdl:message name="ChargeRequest">
    <wsdl:part name="customer" element="tns:Customer"/>
    <wsdl:part name="charge" element="tns:Charge"/>
  </wsdl:message>
  <wsdl:message name="ChargeResponse">
    <wsdl:part name="result" element="tns:ChargeResult"/>
  </wsdl:message>
  <wsdl:portType name="OnlineChargingPortType">
    <wsdl:operation name="Charge">
      <wsdl:input message="tns:ChargeRequest"/>
      <wsdl:output message="tns:ChargeResponse"/>
    </wsdl:operation>
  </wsdl:portType>
  <wsdl:binding name="OnlineChargingBinding" type="tns:OnlineChargingPortType">
    <soap:binding transport="http://schemas.xmlsoap.org/soap/http"/>
    <wsdl:operation name="Charge">
      <soap:operation soapAction="http://www.example.com/onlinecharging/Charge"/>
      <wsdl:input>
        <soap:body use="literal"/>
      </wsdl:input>
      <wsdl:output>
        <soap:body use="literal"/>
      </wsdl:output>
    </wsdl:operation>
  </wsdl:binding>
  <wsdl:service name="OnlineChargingService">
    <wsdl:port name="OnlineChargingPort" binding="tns:OnlineChargingBinding">
      <soap:address location="http://www.example.com/onlinecharging"/>
    </wsdl:port>
  </wsdl:service>
</wsdl:definitions>
Thông tin nào được yêu cầu khi gửi dữ liệu đến dịch vụ web?
A. Mã khách hàng và số tiền nạp
B. Tên khách hàng và số tiền nạp
==C. Mã khách hàng, tên khách hàng và số tiền nạp
D. Mã khách hàng, tên khách hàng, số tiền nạp và số thẻ tín dụng

Câu 40. Cho định nghĩa WSDL:
<?xml version="1.0" encoding="UTF-8"?>
<definitions xmlns="http://schemas.xmlsoap.org/wsdl/" xmlns:tns="http://www.example.com/accountRegistration" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" name="AccountRegistration" targetNamespace="http://www.example.com/accountRegistration">
  <types>
    <xsd:schema elementFormDefault="qualified" targetNamespace="http://www.example.com/accountRegistration">
      <xsd:element name="Account">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="username" type="xsd:string"/>
            <xsd:element name="password" type="xsd:string"/>
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="AccountResponse">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="success" type="xsd:boolean"/>
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>
    </xsd:schema>
  </types>
  <message name="RegisterAccount">
    <part name="parameters" element="tns:Account"/>
  </message>
  <message name="RegisterAccountResponse">
    <part name="parameters" element="tns:AccountResponse"/>
  </message>
  <portType name="AccountRegistrationPortType">
    <operation name="RegisterAccount">
      <input message="tns:RegisterAccount"/>
      <output message="tns:RegisterAccountResponse"/>
    </operation>
  </portType>
  <binding name="AccountRegistrationBinding" type="tns:AccountRegistrationPortType">
    <soap:binding transport="http://schemas.xmlsoap.org/soap/http"/>
    <operation name="RegisterAccount">
      <soap:operation soapAction="http://www.example.com/accountRegistration/RegisterAccount"/>
      <input>
        <soap:body use="literal"/>
      </input>
      <output>
        <soap:body use="literal"/>
      </output>
    </operation>
  </binding>
  <service name="AccountRegistrationService">
    <port name="AccountRegistrationPort" binding="tns:AccountRegistrationBinding">
      <soap:address location="http://www.example.com/accountRegistration"/>
    </port>
  </service>
</definitions>
Dịch vụ web tên gì?
==A. AccountRegistrationService
B. AccountRegistration
C. AccountRegistrationPortType
D. AccountRegistrationBinding